%%第二章 
\chapter{ELF文件代码插入技术}

%%
%%测试一下dia好不好用，如图\ref{testdia1}所示。
%%
%%\begin{figure}[h!]
%%     \centering
%%     \includegraphics[width=90bp]{figure/testdia1.eps}
%%     \caption{dia示例图片1}     
%%     \label{testdia1}
%%\end{figure}
%%
%%上面这个感觉有点大，改小点，如图\ref{testdia2}所示。
%%\begin{figure}[h!]
%%  \centering
%%  \includegraphics[width=125bp]{figure/testdia2.eps}
%%  \caption{dia示例图片2}
%%  \label{testdia2}
%%\end{figure}


%% 2.1

\section{ELF文件结构介绍}


ELF的文件格式在\cite{elf1.2}中有着详尽的描述，
本节介绍笔者认为对于ELF文件注入技术有重要关联的地方。

\subsection{ELF文件类型}

ELF文件主要有三种类型，分别是：

\begin{itemize}
 \item 可重定位文件（Relocatable File）
 \item 可执行文件(Executable File)
 \item 共享目标文件(Shared Object File)
\end{itemize}

可重定位文件就是常见的.o文件，也叫目标文件。这类文件包含了代码和数据，
但是其中的外部地址引用都未重定位，可以被与其他可重定位文件链接生成
可执行文件或者共享目标文件。

可执行文件在linux下往往没有扩展名，例如/bin/ls就是典型的这一类文件。
他们共同的特点是可以直接执行。但是ELF可执行文件在也分为两类：
静态链接的和动态链接的。区别在于静态链接的文件所需要的库都已经被链接至
可执行文件中。而动态链接的文件在运行时才与库链接。
gcc(GNU Compile Collection, GNU编译器套装)默认生成动态链接的可执行文件；
通过增加--static选项，可以生成静态链接的可执行文件。

共享目标文件即linux下的.so文件，也常被叫做动态共享库。它们类似.o文件，并没有被
完全链接，但是区别在于，它们用于在运行时与动态链接的可执行文件进行链接。

我们的操作目标，即vxWorks系统镜像，可以归类为静态链接的可执行文件。
它的特点是已经被完全链接和重定位。

\subsection{链接视图与执行视图}

每一种ELF文件都有着相似的基础结构。
ELF文件格式刚刚被生成的时候，是存储在磁盘中；
然而它最终的用途是被加载和执行。
这里有点类似从一个“程序”到“进程”的转化。
当ELF存在于磁盘中时，系统以某种视角来看待它;
然而当它被加载到主存，系统就需要以另一种视角来看待它。
这就是ELF文件的链接视图和执行视图，如图\ref{elf-map}。
任何ELF文件都存在链接视图，而执行视图存在于共享目标文件和可执行文件中。

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.55\textwidth]{figure/elf-map.png}
  \caption{链接视图与执行视图}
  \label{elf-map}
\end{figure}

\textbf{链接视图：}在对ELF文件进行链接的过程中，
链接器从链接视图来看待ELF文件，
链接器认为ELF文件被划分为一个个节区（section），
节区中包含代码或者数据。
链接器通过合并这些段来形成新的ELF文件。

\textbf{加载视图：}当加载器对ELF可执行文件执行加载操作时，
它眼中的ELF文件是被划分为了一个个段（segmentation）。
在一个使用分页机制的系统中，
每个段都是按照页大小（例如4KB）进行对齐的。
加载器的任务就是把每个段的页拷贝到主存的合适位置。
（使用虚拟存储器的系统中，加载器不拷贝数据，
只建立虚拟内存和磁盘文件的关联，
在此可以简单认为加载器按照段结构进行了ELF文件到主存的拷贝）

ELF文件中，存在以下的数据结构，来实现链接视图和执行视图。
（在.o文件中，不存在执行视图）

%\begin{itemize}
 % \item ELF头部
%\end{itemize}


\textbf{ELF文件头部：}
图\ref{header}是一个典型的ELF文件头的内容
ELF文件头位于ELF文件的起始部分，是两种视图都必要的数据结构。
除了标志该文件是ELF文件及其类型之外，头部最重要的作用在于，
指明了节区头部表和程序头部表的偏移，以及节区和段的数量。
%\begin{itemize}
 % \item 节区和节区头部表
%\end{itemize}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{figure/header.png}
  \caption{ELF文件头部}
  \label{header}
\end{figure}

\textbf{节区和节区头部表：}
图\ref{sections}展示了/bin/ls文件的节区头部表，
在链接视图中，节区用于划分文件中不同类型的数据。
例如.text节用于存放代码，.data节用于存放数据等。
链接两个目标文件的的其中一步，就是把
节区头表为是所有节区的一个索引，
通过解析节区头表可以找到文件的所有节区。

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{figure/sections.png}
  \caption{节区头部表}
  \label{sections}
\end{figure}
%\begin{itemize}
 % \item 段和程序头部表
%\end{itemize}

\textbf{段和程序头部表：}
图\ref{programs}是/bin/ls的程序头部表。
段是执行视图中的对ELF文件的划分，
ELF文件被加载和执行的就是一个个段。
一般来说，每个节区映射到唯一一个段，而一个段包含不同的节区。
段没有名字，但有类型和属性，
类型一般指明该段是否需要加载至内存，
例如需要加载器加载到主存中的段的类型为“LOAD”；
而段的属性则表明了该段能否被读/写/执行。

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{figure/programs.png}
  \caption{程序头部表}
  \label{programs}
\end{figure}
在一个典型的linux可执行文件中，
第一个LOAD类型的段一般具有可读和可执行的属性，
该段对应的节区为所有含有代码的节区，例如.init节、.text节和.finit节。

与节区头部表类似，程序头部表是所有段的一个索引。
程序头部表还指明了每个段所包含的节区。


\subsection{文件空间和地址空间}

上文介绍了ELF文件的两种不同的视图，
理解两个视图的区别和联系能帮助我们找到可以插入代码的位置。
然而，这还是不够的。
我们插入的代码必须加载到一定的地址才能被运行。
这就需要理解ELF文件与地址空间的关系。

在节区头部表和程序头部表中，
不但指定了节区或者段在文件中的位置，
还指定了节区或者段在内存中的加载地址。
例如如图\ref{sections}所示，
/bin/ls程序包含的.text节在文件中的偏移是0x3020，
而加载地址为0x8048320。

打个比方，如果在论文中新加入了一个章而没有更新目录，
那么读者很可能会忽略这一章。
在ELF文件中插入代码，如果不更新相应的数据结构（节头表和程序头表），
除了增大了文件的体积之外和导致文件不能运行之外，
没有任何意义。

由于插入的代码会影响文件内容在文件中的偏移，
因此相应节头表和段表的偏移字段必须被更新。
如果这项工作没有出现错误，
那么修改后的文件至少是可以正常地像原先一样执行的。
然而，要让我们插入的代码也在加载时被映射到
程序的地址空间中，那插入的部分必须拥有合法的载入地址。

这就带来了两个问题，一是哪些地址空间是空闲并可以使用的，
二是如何让插入的代码刚好使用这部分地址空间。
这两个问题将一直存在于后文对具体技术的讨论中。

第一个问题与操作系统和硬件平台有关，
在一个运行在IA32上的Linux系统来说，
由于段的起始地址要按照4KB的页大小进行对齐，
因此加载段之间将会有0～4KB的空余地址空间。
插入的代码可以用于映射到这部分空间。

第二个问题包含很多细节性的修改，
通过小心地把代码插入到一个段的最后，
并修改段的大小，
同时更新后面所有段和节的文件偏移，
就可以让我们的代码刚好用上这一段地址空间。

如果解决了这两个问题，程序再次执行时，插入的代码就已经被加载到
相应的地址空间了。
剩下的问题则会根据需求变化。
例如如何让插入的代码得到执行和在何时执行，
以及如何在插入的代码中使用库函数等。
这些问题将留在具体技术中讨论。

\section{静态链接文件插入技术}

本节将介绍几种典型的，针对静态链接的ELF可执行文件的插入技术。
在前文中，我们讨论了关于文件空间和地址空间的问题。
得出的结论是我们必须兼顾这个方面。
然而在实际的技术中，
要真正向ELF文件中插入代码并使我们的代码运行起来，
特别是能够在代码体中做一些事情，
还需要很多的努力。

\subsection{利用nop指令串插入代码}

首先介绍一种最简单的代码插入方式。
一本优秀的反汇编教材\cite{heike}中
讲述了利用nop串向ELF文件插入代码的方法。
由于编译器在生成ELF文件时，
会对一些地址进行对齐（例如函数的起始地址）。
多余的空间会使用nop指令（操作码为0x90）进行填充。
由于地址对齐而留下的nop指令串便可以供我们随意使用。

这些可用的nop指令串有这样两个条件：
在nop串第一个nop指令的前面必须是ret或者jmp指令，
而且最后一个nop串之后的地址能够被10h整除。
代码\ref{nop}是/bin/ls文件反汇编之后的一部分代码，
代码中从地址805ac43h开始，到805ac4fh结束的nop指令串
满足上述的两个条件
（前面紧挨的指令为jmp，nop串结束后的地址为805ac50h）。
因此这些nop都可以被改写，
而不影响程序运行。

\begin{lstlisting}[
  language={[x86masm]Assembler},
  caption={/bin/ls中存在的nop指令串},
  label={nop},
]
805ac3e:       5f                  pop    edi
805ac3f:       5d                  pop    ebp
805ac40:       c3                  ret
805ac41:       eb 0d               jmp    805ac50<__sprintf_chk@plt+0x10f90>
805ac43:       90                  nop
805ac44:       90                  nop
805ac45:       90                  nop
805ac46:       90                  nop
805ac47:       90                  nop
805ac48:       90                  nop
805ac49:       90                  nop
805ac4a:       90                  nop
805ac4b:       90                  nop
805ac4c:       90                  nop
805ac4d:       90                  nop
805ac4e:       90                  nop
805ac4f:       90                  nop
805ac50:       f3 c3               repz ret
\end{lstlisting}

虽然这样的nop指令串在/bin/ls这样的文件中有很多，
但每一段都不是太长，容不下很多代码。
一个最简单的办法就是，
在每个nop串快要用完的时候，使用jmp或其他指令，
跳转到下一个nop串的开始处。
这样我们就可以利用几乎所有的nop指令串
（除非有的实在太短，以至于写不下jmp指令）。
\cite{heike}中给出了一个简单的手动修改的示例，劫持一个可执行文件，
在运行它时先打印字符串“hello”。
示例的工作可以归结为以下几个步骤：

（1）修改ELF文件入口点处的两条指令，
替换为jmp指令，跳转地址为第一个nop指令串。

（2）在nop串中写入使用系统调用
打印“hello\textbackslash n”的汇编代码。
如果一个nop串不足，则跳转后继续使用下一个nop串。

（3）打印代码的最后，加入ELF入口点被修改的两条指令。

（4）使用jmp跳转回入口点处的第三条指令。

修改完成后，当我们再次在终端中执行该可执行文件时，
终端中会首先打印出一行“hello”，接着才是它原先的工作。

这种修改方式虽然原理简单，
但若对较大的文件注入大量的代码，
手工操作的工作量会很大。
最好的办法是使用\cite{infelf}提供的infelf工具，
该工具把使用nop进行插入的原理流程化，
从而帮助我们自动完成插入。

infelf工具在流程上与前面所述差异不大，
但是通过它可以劫持程序执行流的任意的位置，
比如任意一个函数的入口，而不仅限于入口点。
该工具的出现说明向nop串插入代码，
完全可以成为一种常规的插入方式。

然而，如果要插入大量的代码，
程序中仅有的一点nop指令串能够用吗？
我们做一个简单的统计，来看看一个ELF可执行文件中，
大概能留下多少可供使用的nop指令串。
我们选取了一些典型的ELF文件，包括一个最简单的C语言“hello,world!”程序，
若干/bin目录下的实用程序和我们的目标vxWorks镜像。
统计结果如表\ref{nopbytes}所示。

\begin{table}
  \centering
  \caption{典型ELF文件中的nop串占据的空间}
  \label{nopbytes}
  \begin{tabular}{l|l|l}
     \hline
     ELF文件       & 文件大小（字节）& nop串大小（字节） \\ \hline
 “hello,world!”程序  & 7339           & 30                 \\ \hline
     /bin/ls      & 108708          & 921                \\ \hline
     /bin/rm      & 303484         & 1653                \\ \hline  
     /bin/bash    & 924892        & 13723              \\ \hline
     vxWorks系统镜像 & 1337184        & 21114              \\ \hline
  \end{tabular}
\end{table}  

由此可见，随着ELF文件体积的增大，
可用的nop串空间也几乎在正比例扩张，
二者的比例大概维持在100:1的数量级。
除了在最简单的“hello,world!”程序中几乎什么都插不下之外，
具有一些实用功能的应用程序都有着比较可观的空间。
试想一下，假若/bin/bash中13KB的nop串被全部塞满恶意代码，
完全可以对系统产生严重的打击。

\subsection{在代码段的最后分区插入代码}

Silvio Cesare由于在1998年提出的最原始的UNIX病毒模型\upcite{silvio}，
而曾被称为“ELF大师（ELF master）”。
在这一病毒模型中，病毒在感染其他文件时，
采取了一种不同的方式。
由于在Linux系统下，ELF文件中的可加载段需要进行地址对齐，
于是在段之间会产生了较多的空闲的地址空间，
可以在在这一空间中插入外来的代码。
%%%
具体来说是在第一个可加载段（俗称的代码段）最后一节的最后插入代码。
这一方案具有很大的通用性，
因为不论ELF文件有多大，
平均下来，每个段之间都有大概4KB/2=2KB的空间供我们插入。
即使总共才只有7KB的“hello,world!”程序也不例外。
%%
而且由于Linux为了节省物理内存，
采取了部分物理页面映射两次到虚拟页面的做法，
这一空间甚至有可能大于4KB。
%%
由于这一方案提供了一个比较有通用性的插入办法，
后续的很多研究和实践，如\cite{simple,shared,cerberus,subversive,prototype}，
都是围绕它进行的改进或者在其基础上的进一步研究。

下面简要描述了这一插入算法。


1、修改ELF文件头中的entrypoint字段，指向即将插入代码的位置
（代码段offset+filesz）

2、找到ELF中的第一个可加载段（代码段），将该段的filez字段和memsz字段增加
要插入代码的大小。

3、对于所有在代码段之后的段，将其offset增加一页（4KB）的大小。

4、对于代码段的最后一个节区，将其len字段增加插入代码长度大小。

5、对于在代码段之后的所有节区，将其len字段增加一页（4KB）的大小。

6、将插入代码的长度填充到1页（4KB），然后拷贝到预定的插入代码的位置。

7、修改的插入代码，插入一条jmp指令，跳转回原先的entrypoint。

在这一算法的基础上，我实现和完善了这一方法的python版本（见附录\ref{???}）。
并增加了一些自定义的功能。下面借助一个例子来说明其原理。

这个例子的目标是在一个hello程序中插入代码，
插入代码的任务则是借助Linux的系统调用，
打印一行字符串"foo"。
插入成功的标志是运行hello程序时，先打印一行"foo"，再打印一行"hello"。

图\ref{main1}和\ref{main2}分别展示了在插入代码前后的程序头表的变化。
我们可以很容易在这里发现一些上面的算法所描述的改变，
例如第一个LOAD段的长度被增加了0x26,
而从第二个LOAD段开始，所有的段的偏移量都增加了0x1000，即4K等。
类似地，节区头部表中的一些数据结构也被修改，在此就不再赘述了。

\begin{figure}[h!]
  \label{main}
   \centering
  \begin{tabular}{cc}
    \subfigure[插入前]{
      \label{main1}
      \includegraphics[width=0.6\textwidth]{figure/main.png}
     }  \\
    \subfigure[插入后]
     {
        \label{main2}
      \includegraphics[width=0.6\textwidth]{figure/main2.png}
     }
    \end{tabular}
  \caption{可执行文件插入代码前后的程序头表对比}
\end{figure}
          
图\ref{??}展示了插入的代码如何通过修改程序入口点
对程序原有的正常执行流进行篡改


\subsection{在代码段之前插入代码}

\section{动态链接文件劫持技术}

\subsection{利用修改共享库地址和名称进行劫持}

\subsection{利用修改plt和got进行劫持}

\section{ELF文件插入技术总结}

\section{ELF插入技术在vxWorks中的使用分析}

%%
%%\section{C\TeX{}套装 [Windows Only]}
%%
%%C\TeX{}套装是Windows下为中文优化的\LaTeX{}系统套件，主要基于MiKTeX系统，
%%集成了编辑器WinEdt和其他相关软件。整个系统封装在一个安装程序中，
%%安装方法与常规软件相同，无需任何配置，适合大部分Windows用户使用。
%%
%%\begin{description}
%%    \item[下载地址] \hfill
%%    \begin{description}
%%        \item[官方页面]
%%            \url{http://www.ctex.org/CTeXDownload}
%%        \item[未来花园]
%%            稍后我们也会提供未来花园上的下载页面，敬请关注
%%    \end{description}
%%    \item[安装方法] \hfill
%%        \begin{itemize}
%%            \item[] 与常规软件的安装方法差不多
%%            \item[] 一直下一步稍加一些自定义（如安装路径）即可
%%        \end{itemize}
%%\end{description}
%%
%%\section{\TeX{}Live [ Windows \& Linux ]}
%%
%%\TeX{}是自由软件，有很多发行版本，就像Linux的Ubuntu、Fedora等等。
%%每个发行版本都是一套工具集合，包括plain\TeX{}，\LaTeX{}，pdf\TeX{}，dvips等。
%%其中比较流行的是\TeX{}Live，也包含在CTAN的开源镜像中，
%%目前的最新版本是\TeX{}Live 2012。
%%
%%推荐通过下载ISO镜像文件的方式安装：
%%\begin{description}
%%    \item[官方说明]
%%        \url{http://www.tug.org/texlive/acquire-iso.html}
%%    \item[下载地址] 官方地址会自动跳转寻找"最近"镜像，还有几个较快的教育网镜像
%%    \begin{description}
%%        \item[官方地址]
%%            \url{http://mirror.ctan.org/systems/texlive/Images/texlive2012.iso}
%%        \item[清华镜像]
%%            \url{http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/}
%%        \item[北交镜像]
%%            \url{http://mirror.bjtu.edu.cn/CTAN/systems/texlive/Images/}
%%        \item[未来花园]
%%            稍后我们也会提供未来花园上的下载页面，敬请关注
%%    \end{description}
%%    \item[安装方法] \hfill
%%    \begin{enumerate}
%%        \item 通过虚拟光驱挂载镜像也可以直接打开或解压缩不过会比较慢
%%        \item 双击运行光盘镜像或者运行脚本
%%        \item[] Windows 用户可以直接双击运行\textsl{install-tl.bat}
%%        \item[] Linux 用户可以在终端下执行命令\textsl{./install-tl}
%%        \item 按照提示下一步即可，安装大致耗时10$\sim$20分钟，受机器配置影响。
%%    \end{enumerate}
%%\end{description}
%%
%%当然官方也提供了通过网络安装的方式，虽然通过可以通过镜像选择达到比较快的速度，
%%但是这里简便期间不再赘述，有兴趣的同学可以参考官方说明
%%\url{http://www.tug.org/texlive/acquire-netinstall.html}。
%%
%%\section{Mac\TeX{} [ Mac ]}
%%
%%Mac\TeX{}是基于\TeX{}Live为Mac系统设计的套件。
%%
%%\begin{description}
%%    \item[官方网站]
%%        \url{http://tug.org/mactex/}
%%    \item[下载地址] 官方地址会自动跳转寻找"最近"镜像，还有几个较快的教育网镜像
%%    \begin{description}
%%        \item[官方地址]
%%            \url{http://mirror.ctan.org/systems/mac/mactex/MacTeX.pkg}
%%        \item[清华镜像]
%%            \url{http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/mac/mactex/}
%%        \item[北交镜像]
%%            \url{http://mirror.bjtu.edu.cn/CTAN/systems/mac/mactex/}
%%        \item[未来花园]
%%            稍后我们也会提供未来花园上的下载页面，敬请关注
%%    \end{description}
%%    \item[安装方法] 同一般软件安装，下一步即可
%%\end{description}
%%
%%\section{关于编辑器}
%%
%%以上介绍了三款\LaTeX{}套装，涵盖了主流的三大平台，除了C\TeX{}自带了WinEdt，
%%其余两款均需要自己选择编辑器，理论上任何文本编辑器都是可以使用的，
%%如Windows上的Notepad++，Linux/MacOS上的vim，emacs，
%%一方面要考虑对\LaTeX{}的支持，一方面还是自己的熟悉程度。
%%
%%这里推荐一款大众化的编辑器\TeX{}maker，它是跨平台的，支持Windows、Linux和MacOS。
%%
%%\begin{description}
%%    \item[官方网站]
%%        \url{http://www.xm1math.net/texmaker/}
%%    \item[下载地址]
%%        \url{http://www.xm1math.net/texmaker/download.html}
%%    \item[相关说明]
%%    \begin{itemize}
%%        \item 安装同一般软件的安装
%%        \item 配置Xe\LaTeX{}的编译，选择菜单栏“选项”->“配置\TeX{}Maker”，
%%        \item[] 在“\LaTeX{}”一栏填写
%%            \texttt{xelatex -interaction=nonstopmode\%.tex}
%%    \end{itemize}
%%\end{description}
%%
%%\section{关于编译}
%%
%%\LaTeX{}的文件是通过编译生成的，对于本模板和毕业设计论文而言，
%%需要经过代码\ref{code-compile}所示步骤（以sample-bachelor.tex为例）：
%%\begin{lstlisting}[
%%    language={bash},
%%    caption={编译步骤},
%%    label={code-compile},
%%]
%%xelatex sample-bachelor.tex
%%bibtex  sample-bachelor.aux
%%xelatex sample-bachelor.tex
%%xelatex sample-bachelor.tex
%%\end{lstlisting}
%%当然，我们在模板里也提供了编译的执行脚本。
%%
%%\subsection{批处理 [ Windows only ]}
%%
%%进入cmd（Win+R，然后输入cmd），cd到BUAAthesis对应目录，
%%如{\verb D:\BUAAthesis\ }，然后运行{\verb msmake }即可。
%%
%%\subsection{Makefile [ Windows(cygwin) / Linux / MacOS ]}
%%需要要你的命令行环境支持Make，cd到BUAAthesis相应目录，
%%目前支持如代码\ref{code-make}所示的功能:
%%\begin{lstlisting}[
%%    language={bash},
%%    caption={make 命令},
%%    label={code-make},
%%]
%%make bachelor # 编译本科生的\LaTeX{}（文件默认项，亦可直接输入make）
%%make master # 编译研究生的\LaTeX{}文件
%%make clean # 删除编译过程中生成的文件（除了pdf）
%%make depclean # 删除编译过程中生成的文件（包括pdf）
%%\end{lstlisting}
